---
title: 'Proposals'
description: 'Proposals for a Better Earth'
icon: 'map'
---

Social Network aims to be a fully decentralized ecosystem, and as such, is organized in a way that anyone can contribute to the open source code by completing any of the bounties below.
Additionally, if you would like to be a part of proposing new bounties, you will soon be able to make Heart Improvement Proposals (HIPs) on our forum (coming soon).

## Available Bounties

<ResponseField name="Social Network" type="BTC" required>
  Add support for depositing BTC into the Social Network.
  <Expandable title="Bounty">
    <ResponseField name="Social Network" type="contract">
    ## Moving from Bitcoin to the Social Network

      To move BTC from the Bitcoin Network to the Social Network, the following [BIP-341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs) P2TR script transaction must be generated:

      1) Earth Nodes read Bitcoin blocks for any deposits to the Bitcoin Staking Controller at [1bxdfasdf](1bxdfasdf).
      2) Once a deposit is detected, Earth Nodes calculate a new Social Network merkle distributor representing the claims to all BTC deposited on the Social Network.
      3) A new Bitcoin Taproot transaction is serialized and posted on chain as follows by any Earth Node:

      ```
      OP_FALSE
      OP_IF
        OP_PUSH "sn"
        OP_1
        OP_PUSH "$EARTH_NODE_SIGNATURE;$SOCIAL_NETWORK_BLOCK_HEIGHT"
        OP_0
        OP_PUSH $SOCIAL_NETWORK_NEW_MERKLE_ROOT
      OP_ENDIF
      ```

      The above creates an inscription that first pushes block, in order to disambiguate rollup block inscriptions from other types. 
      OP_1 indicates that the next push contains the social network block height for which the data belongs too, and OP_0 indicates that any subsequent data push contains the data itself, 
      since by Taproot restrictions, individual pushes may not be larger than 520 bytes, multiple pushes for block data larger than 520 bytes may be necessary.

      3) As Earth Nodes index both Bitcoin and Ethereum blocks, they have access to all approved Earth Nodes in real time, and thus, are able to determine
      whether a signature as valid. The first Earth Node to successfully include the inscription to the Bitcoin will be considered valid.
      4) Earth Nodes will submit signatures , Earth Nodes will submit their signature to the Social Network Controller, to trigger a transfer of funds to a new Merkle Distributor.
      This transfer will enable a new set of withdrawals to occur, based off of any withdrawal or deposits made to the Social Network Controller since the last block.
      5) Users who deposited their BTC to the Social Network can now safely withdraw their BTC.

      The inscription content is contained within the input of a reveal transaction, and the inscription is made on the first sat of its first output.


    </ResponseField>

  </Expandable>
</ResponseField>

<ResponseField name="Social Network" type="BTC" required>
  Add support for withdrawing BTC from the Social Network.
  <Expandable title="Bounty">
    <ResponseField name="Social Network" type="contract">
      ## Bitcoin Withdrawal

        Since the Social Network uses Bitcoin for data availability, we will require a private key with some bitcoin to spend and create inscriptions with, we can always query all inscriptions by listing the rollup’s bitcoin address’ unspent outputs by using `[listunspent](https://developer.bitcoin.org/reference/rpc/listunspent.html)`. This will provide us with a list of utxos:

        ```nasm
        [                                (json array)
          {                              (json object)
            "txid" : "hex",              (string) the transaction id
            "vout" : n,                  (numeric) the vout value
            "address" : "str",           (string) the bitcoin address
            "label" : "str",             (string) The associated label, or "" for the default label
            "scriptPubKey" : "str",      (string) the script key
            "amount" : n,                (numeric) the transaction output amount in BTC
            "confirmations" : n,         (numeric) The number of confirmations
            "redeemScript" : "hex",      (string) The redeemScript if scriptPubKey is P2SH
            "witnessScript" : "str",     (string) witnessScript if the scriptPubKey is P2WSH or P2SH-P2WSH
            "spendable" : true|false,    (boolean) Whether we have the private keys to spend this output
            "solvable" : true|false,     (boolean) Whether we know how to spend this output, ignoring the lack of keys
            "reused" : true|false,       (boolean) (only present if avoid_reuse is set) Whether this output is reused/dirty (sent to an address that was previously spent from)
            "desc" : "str",              (string) (only when solvable) A descriptor for spending this output
            "safe" : true|false          (boolean) Whether this output is considered safe to spend. Unconfirmed transactions
                                        from outside keys and unconfirmed replacement transactions are considered unsafe
                                        and are not eligible for spending by fundrawtransaction and sendtoaddress.
          },
          ...
        ]
        ```

        We can then take this list of UTXOs and filter it to include only utxos that correspond to our reveal transactions, and additionally, we can order them by timestamp, thus giving us a list of utxo inscriptions for which we can associate an index to a certain block height in our rollup (i.e `utxo[0].witness == rollup_block_height_1_data`)

        Once we have found the utxo with the data for a given block, we can call `gettransaction` with the `tx_id` of our utxo, which will return:

        ```nasm
        {                                          (json object)
          "amount" : n,                            (numeric) The amount in BTC
          "fee" : n,                               (numeric) The amount of the fee in BTC. This is negative and only available for the
                                                  'send' category of transactions.
          "confirmations" : n,                     (numeric) The number of confirmations for the transaction. Negative confirmations means the
                                                  transaction conflicted that many blocks ago.
          "generated" : true|false,                (boolean) Only present if transaction only input is a coinbase one.
          "trusted" : true|false,                  (boolean) Only present if we consider transaction to be trusted and so safe to spend from.
          "blockhash" : "hex",                     (string) The block hash containing the transaction.
          "blockheight" : n,                       (numeric) The block height containing the transaction.
          "blockindex" : n,                        (numeric) The index of the transaction in the block that includes it.
          "blocktime" : xxx,                       (numeric) The block time expressed in UNIX epoch time.
          "txid" : "hex",                          (string) The transaction id.
          "walletconflicts" : [                    (json array) Conflicting transaction ids.
            "hex",                                 (string) The transaction id.
            ...
          ],
          "time" : xxx,                            (numeric) The transaction time expressed in UNIX epoch time.
          "timereceived" : xxx,                    (numeric) The time received expressed in UNIX epoch time.
          "comment" : "str",                       (string) If a comment is associated with the transaction, only present if not empty.
          "bip125-replaceable" : "str",            (string) ("yes|no|unknown") Whether this transaction could be replaced due to BIP125 (replace-by-fee);
                                                  may be unknown for unconfirmed transactions not in the mempool
          "details" : [                            (json array)
            {                                      (json object)
              "involvesWatchonly" : true|false,    (boolean) Only returns true if imported addresses were involved in transaction.
              "address" : "str",                   (string) The bitcoin address involved in the transaction.
              "category" : "str",                  (string) The transaction category.
                                                  "send"                  Transactions sent.
                                                  "receive"               Non-coinbase transactions received.
                                                  "generate"              Coinbase transactions received with more than 100 confirmations.
                                                  "immature"              Coinbase transactions received with 100 or fewer confirmations.
                                                  "orphan"                Orphaned coinbase transactions received.
              "amount" : n,                        (numeric) The amount in BTC
              "label" : "str",                     (string) A comment for the address/transaction, if any
              "vout" : n,                          (numeric) the vout value
              "fee" : n,                           (numeric) The amount of the fee in BTC. This is negative and only available for the
                                                  'send' category of transactions.
              "abandoned" : true|false             (boolean) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the
                                                  'send' category of transactions.
            },
            ...
          ],
          "hex" : "hex",                           (string) Raw data for transaction
          "decoded" : {                            (json object) Optional, the decoded transaction (only present when `verbose` is passed)
            ...                                    Equivalent to the RPC decoderawtransaction method, or the RPC getrawtransaction method when `verbose` is passed.
          }
        }
        ```

        Finally, in the `decoded` field, we can get the witness data by reading the `witness` field for the first input of the decoded transaction. We can then parse our witness data and read our block data accordingly.

        With this witness data, an Earth node can now 


    </ResponseField>

  </Expandable>
</ResponseField>